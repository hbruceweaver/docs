---
title: Rate Limits
description: 'API rate limits and quotas'
---

## Overview

Rate limits protect the API from abuse and ensure fair access for all users.

## Limits

### API Requests

| Resource | Limit |
|----------|-------|
| API requests | 1,000/minute |
| Job creation | 100/minute |

### Concurrent Jobs

| Plan | Concurrent Jobs |
|------|-----------------|
| Free | 5 |
| Starter | 10 |
| Growth | 25 |
| Scale | 50 |
| Enterprise | Custom |

## Rate Limit Headers

Responses include rate limit information:

```http
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 950
X-RateLimit-Reset: 1705312800
```

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Max requests per window |
| `X-RateLimit-Remaining` | Requests remaining |
| `X-RateLimit-Reset` | Unix timestamp when limit resets |

## Exceeding Limits

When limits are exceeded:

```json
{
  "error": "Rate limit exceeded. Try again in 30 seconds."
}
```

HTTP Status: `429 Too Many Requests`

## Best Practices

### 1. Implement Backoff

```javascript
async function createJobWithRetry(params, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await createJob(params);
    } catch (error) {
      if (error.status === 429 && i < maxRetries - 1) {
        const delay = Math.pow(2, i) * 1000;
        await new Promise(r => setTimeout(r, delay));
        continue;
      }
      throw error;
    }
  }
}
```

### 2. Batch Requests

Instead of creating jobs one at a time, use batch_size where supported:

```json
{
  "type": "nano_banana_2",
  "params": {
    "batch_size": 4,
    ...
  }
}
```

### 3. Monitor Headers

Check remaining quota before making requests:

```javascript
async function safeRequest(url, options) {
  const response = await fetch(url, options);

  const remaining = response.headers.get('X-RateLimit-Remaining');
  if (remaining && parseInt(remaining) < 10) {
    console.warn('Rate limit nearly exhausted');
  }

  return response;
}
```

### 4. Queue Locally

For high-volume applications, implement a local queue:

```javascript
class JobQueue {
  constructor(ratePerMinute = 50) {
    this.queue = [];
    this.interval = 60000 / ratePerMinute;
    this.processing = false;
  }

  add(job) {
    return new Promise((resolve, reject) => {
      this.queue.push({ job, resolve, reject });
      this.process();
    });
  }

  async process() {
    if (this.processing) return;
    this.processing = true;

    while (this.queue.length > 0) {
      const { job, resolve, reject } = this.queue.shift();
      try {
        const result = await createJob(job);
        resolve(result);
      } catch (error) {
        reject(error);
      }
      await new Promise(r => setTimeout(r, this.interval));
    }

    this.processing = false;
  }
}
```

## Account Pooling

The system automatically distributes jobs across available generation accounts. This means:

- Multiple jobs can run in parallel
- Jobs may queue if all accounts are busy
- Different job types may have different available capacity

Check account status:

```bash
curl "https://higgsfield.ai/api/accounts" \
  -H "Authorization: Bearer hf_your_api_key"
```

## Increasing Limits

Contact support or upgrade your plan for higher limits. Enterprise plans include:

- Custom rate limits
- Priority queue access
- Dedicated account pools
- SLA guarantees
